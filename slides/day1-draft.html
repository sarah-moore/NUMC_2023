<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Foundations of Quantitative Social Science</title>
    <meta charset="utf-8" />
    <meta name="author" content="Sarah Moore" />
    <script src="libs/header-attrs-2.21/header-attrs.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Foundations of Quantitative Social Science
]
.subtitle[
## Day 1 AM
]
.author[
### Sarah Moore
]
.institute[
### Northwestern University
]
.date[
### Math Camp 2023
]

---




# Day 1 Agenda 

- Get to know each other. 

- Acquaint ourselves with the foundations of quantitative social science. 

- Today we will jump around a little bit more than the rest of the days to get through some necessary review: 
  
  - Sets and basics of set operations 
  
  - Algebra refresh 

---

# Who are we? 

Co-Instructors: 

## J. Seawright

- Professor of Political Science and Director of Graduate Studies 

- j-seawright@northwestern.edu 

## Sarah Moore

- PhD Candidate (ABD) in Political Science and M.S. Candidate in Statistics 

- sarahmoore2022@u.northwestern.edu

---
# What is math camp? 

- A primer to (re)introduce you to some topics that will be necessary to moving forward in the quantitative methods sequence in Political Science and Sociology. 

- Allow the instructors to assess the needs of the incoming cohort regarding instructional support. 

- Also an opportunity to meet and network with your new grad school colleagues. 

---

# Now, tell us about you 

Let's get to know each other a bit more: 

- Name

- Pronouns

- Discipline + Subfield 

- Favorite comfort food 

---
# What are we going to cover? 

- Refresh knowledge of foundational mathematical concepts

- Establish base knowledge of computational tools used in social science research. 

- Obtain familiarity with expectations of a graduate level course in methods. 

- Build rapport with cohort members, upper level graduate students, and faculty. 

- Think broadly about the potential use of quantitative methods in social science. 

- Reflect on how well you understand and can apply the concepts addressed in math camp.  

---

# Expectations for Math Camp

- Be respectful of your fellow Math Campers and respect that everyone is here to learn! 

- Review materials (text, slides, problem sets)

- Complete problem sets by the scheduled due date 

- Complete R exercises 

- We don't expect that you will learn everything in depth. This camp is basically just to introduce you to some concepts that you will run into throughout methods courses. 


---

# Broader Expectations

- Read what's assigned, and learn how to skim now. 

- The people around you are your colleagues, not your competition. Our default here is to treat everyone with respect. 

---
# What's the point of taking methods courses to study [insert discipline here]?
---

# Theory Construction 

Social scientists develop and test **theories** that explain certain patterns that exist in the social world. 

These theories emerge out of research questions related to theoretical or empirical puzzles or problem-based inquiries. 

## Theory 

A **theory** is a proposition or set of propositions that explain a certain phenomenon. Theories can be either *causal* or *descriptive*, though more work in contemporary social science is now oriented toward causal explanation. 

A theory specifies a number of **concepts** of interest and explains the relationship between them.

---

# Observable Implications of a Theory  

Empirical social scientists evaluate whether or not theories are true through hypothesis testing. Hypothesis testing is a systematic method of discerning if observed evidence favors the theory given what we expect to observe if the theory were true. 

## Hypothesis and Null Hypothesis 

A **hypothesis** is an observation we would expect if a theory is true. 

A **null hypothesis** is the corresponding observation we would expect if the theory is *not* true. 

---

# Variables

To test the observable implications of theory, we have to systematize how we'd expect to observe it empirically. This first entails translating theoretically abstract concepts into empirical referents that represent concepts--- these are *variables*. 

- The **dependent variable** (Y) is the outcome of interest, whose value is expected to depend on some other variable. The dependent variable may also be referred to as the outcome or response variable.

- The **independent variable** (X) is the theorized cause of the dependent variable, or at least the cause of Y's variation.

---

# Operationalization 

For example, we might be abstractly interested in *socioeconomic inequality.* How do you all suggest that we turn this concept into a variable? 

--

There's no right answer here...There are **many** ways to measure this concept.

--

When we think of **operationalizing** socioeconomic inequality, or any other concept of interest, we need to choose a fixed, systematic measure of this concept to help us identify instances of socioeconomic inequality. 

---

# Developing Hypotheses, An Example 

.pull-left[Our theory states that public approval of politicians is grounded in more than their *present* political careers. We believe that politician approval is dependent on their social activity and image preceding their political careers and that pre-term high profile politicians enjoy more popular approval. ]

--
.pull-right[
&gt;- What are some concepts in this theory and how might we operationalize them into variables? 

&gt;- What is a hypothesis that we can derive from this theory? That is, **what would we observe if this theory is true?**]

---

# Theory Testing

We need tools to evaluate our hypotheses relative to data. A theory's contribution to knowledge and understanding of the world depends on how well the theory performs under these hypothesis tests. 

--

- Empirical methods can be either *qualitative* or *quantitative* in nature-- here we focus on the latter. 

- Quantitative methods use statistical or mathematical analyses to determine whether the accumulated evidence favors the hypothesis proposed relative to the null. Our default is to *favor the null*, and the burden is on the data to show otherwise.

  - There are more nuances to hypothesis testing that we will get into later next week. 

---

# From Theory to Empirics 

- Observations about the world around us constitute *data*. 

- When we think about observing quantitative data, there are a lot of things to keep in mind: the bounds, the set of possible values, quantifying abstract concepts, and more. 

- While we will use applied probability and statistics to reach conclusions about our data, there are intermediate steps and additional keys to navigating the inter-related processes of data collection and analysis. 

- These intermediate steps are based in logic, set theory, algebra, calculus, etc. We will introduce or re-introduce all of these constitutive parts so that once we get to the coursework in 403 and beyond, you can always revisit this material to make sense of the foundations of more advanced methods. 

---

# Sets and Logical Possibilities  

&gt;- We measure and assign values to higher order concepts that we turn into variables. How we measure something and the bounds of its measurement are consequential to how we then analyze it.


## Sets 

A collection of elements. 

You can have a set composed of numbers or other *things*, such as names of people, places, or other non-numeric values.

`\(A\)` = {cats, rabbits, dogs}

`\(B\)` = {0.5, 0.15, 0.35}


---

# Types of numerical elements

- Natural numbers, `\(\mathbb{N}\)`: positive whole numbers, including 0: `\(\{(0), 1, 2, 3, ... \}\)` 

- Integers, `\(\mathbb{Z}\)`: negative and positive numbers including zero: `\(\{..., -3, -2, -1, 0, 1, 2, 3, ... \}\)`

- Rational numbers, `\(\mathbb{Q}\)`; any number that can be represented by the quotient p/q: `\(\{1/2, 4, -3, 3/2\}\)` 

- Real numbers, `\(\mathbb{R}\)`: any point on the number line: `\(\{-899.8, 22, 4/5, \sqrt{\pi}\}\)` 

- Imaginary numbers, `\(\mathbb{I}\)`: a number times the imaginary number `\(i\)`, which has no meaningful value, `\(i=\sqrt{-1}\)` 

- Complex numbers, `\(\mathbb{C}\)`: a value consisting of both a real and imaginary number, often in the form `\(a+bi\)` 
---

# Measurement of elements in a set

--

## Qualitative Difference 

- **Nominal**: no mathematical relationship between the variables, values are labels with no ordered relationship

- **Ordinal**: categorical variable with set, non-numeric relationship between values, order of values is meaningful 

--

## Quantitative Difference 

- **Interval**: equidistant from one value to the next, but there is no meaningful zero 

- **Ratio**: equidistant from one value to the next, there is a meaningful zero

---

# Measurement: Examples

Here are some examples of each of these types of measurements: 

--

- **Nominal**: Classes available in the sociology department
  &gt;- Stratification, Social Networks, Collective Memory 
--

- **Ordinal**: Your satisfaction with classes you have taken in grad school on a scale from 1 to 4 

  &gt;- Very Dissatisfied (1) - (2) - (3) - Very Satisfied (4)
--

- **Interval**: Scores on entrance exams 
  &gt;- 130-170 on GRE 
  
--

- **Ratio**:  The number of hours that you spend studying for classes each week
  &gt;- 0 hours, 6 hours, 18 hours 

--

**What are some other examples for these measurement types?**
---

# Sets, Variables, and Sample Spaces

- Once we know *how* to characterize variables relative to their higher order concept, must also consider: 

  &gt;- Sample space: set containing all the values a variable can take
  
  &gt;- Subsets: subgroups of a set or sample space
  
---
# Set Notation  

Sets and set operations have notation conventions: 

- There exists, `\(\exists\)` 

- For all, `\(\forall\)`

- Union `\(\cup\)`; Intersection `\(\cap\)` 

- Excluding `\(\notin\)`, `\(\neg\)`

- Empty set `\(\emptyset\)`

- Element `\(\in\)`

- Equivalent `\(\equiv\)`

- Such that (s.t) or `\(|\)`, e.g. `\(\{x | x&gt;7\}\)`

- Subset `\(\subset, \subseteq\)` (these function roughly like the less than/less than equal to, but for sets)

---

# Displaying Sets 

- Roster notation: `\(\{x_1, x_2, ... \}\)`, simply lists out the elements of the set 

- Set builder notation: `\(\{ x | x \in N, x&lt;4 \}\)`, uses set notation to specify the parameters of the set 

  &gt;- Try one: `\(A = \{x | x \in \mathbb{R}, x &lt; 200\}\)`
  
  &gt;- Read "Set A is a set of all x such that x is a real number less than 200." 

---

# Characterizing Sets 

- **Open sets** have a fuzzy boundary. This is the set version of open brackets (). **Closed sets** have clear and firm boundary. This is the set version of closed brackets [ ]. 

- Finite (finite number of elements) or Infinite (no limit)

- Countable or Uncountable: elements can be counted or not (e.g `\(\{ 0,1\}\)` is countable )

- Ordered and Unordered sets: ordered set has significance in order while in unordered, no significance in ranking

---

# Characterizing Sets 

- Subset: elements of some sets are contained within a second set, e.g. even integers and integers. (proper subset: `\(\subset\)`, subset: `\(\subseteq\)`)

- Cardinality: number of elements

- Empty set: no elements. 

- Universal Set (the universe: all elements)

---

# Set Operations

The images on the following slides were pulled from [this site](https://www.probabilitycourse.com/chapter1/1_2_2_set_operations.php). 

---

# **Union**: `\(A \cup B\)` 

Joining two sets together, the equivalent of adding all of the elements of each set. 

--

Here we highlight all of the elements in `\(A\)` **OR** `\(B\)`. 

&lt;img src="images/union.png" width="400" height="300" style="display: block; margin: auto;" /&gt;

---

# **Intersection**: `\(A \cap B\)` 

Finding the elements that are shared between 2+ sets. 

--
Here we highlight all of the elements in `\(A\)` **AND** `\(B\)`. 

&lt;img src="images/intersection.png" width="450" height="300" style="display: block; margin: auto;" /&gt;

---
# **Disjoint Sets**: 

- Two or more sets are **disjoint** if their intersection is empty.

--

For example, `\(A \cap B \cap C = \emptyset\)`. 

&lt;img src="images/disjoint.png" width="400" height="300" style="display: block; margin: auto;" /&gt;


---
# **Difference**: A-B 

The elements of one set less the elements of another. 

--

Here we show the difference `\((A-B)\)`. 

&lt;img src="images/difference.png" width="400" height="300" style="display: block; margin: auto;" /&gt;

---

# **Complement**: `\(A^C\)`

The elements in the universal set `\(U\)` not in the specified set. 

--

For example, `\(A^C\)` indicates all the elements *NOT* in `\(A\)`. 
&lt;img src="images/complement.png" width="400" height="300" style="display: block; margin: auto;" /&gt;


---

# **Partition**

A grouping of elements in a universal set such that each element belongs to at least one subset.

--

Here all of the elements of the universal set `\(S\)` are grouped into subsets `\(A_2, A_2, A_3, A_4\)`. 

&lt;img src="images/partition.png" width="400" height="300" style="display: block; margin: auto;" /&gt;

---

# **Cartesian Product**: `\(A \times B\)`

Set of all the ordered pairs possible between the elements of `\(A\)` and `\(B\)`. 

--

```r
a = c('trees', 'apples', 'rivers')
b = c('pencil', 'paper', 'chalk')

expand.grid(a = a, b = b)
```

```
##        a      b
## 1  trees pencil
## 2 apples pencil
## 3 rivers pencil
## 4  trees  paper
## 5 apples  paper
## 6 rivers  paper
## 7  trees  chalk
## 8 apples  chalk
## 9 rivers  chalk
```
---
# Logical and Relational Operators 


|notation |meaning                  |
|:--------|:------------------------|
|&amp;        |AND                      |
|&amp;#124;   |OR                       |
|!        |NOT                      |
|&lt;        |LESS THAN                |
|≤        |LESS THAN OR EQUAL TO    |
|&gt;        |GREATER THAN             |
|≥        |GREATER THAN OR EQUAL TO |
|==       |EXACTLY EQUAL TO         |
|!=       |NOT EQUAL TO             |
|%in%     |IN THE SET               |

---

# Algebraic Properties

1.  **Associative property** `\((a+b)+c=a+(b+c)\)` and `\((a\times b)\times c=a\times (b \times c)\)`

2.  **Commutative property** `\(a+b=b+a\)` and `\(a\times b=b\times a\)`

3.  **Distributive property** `\(a(b+c)=ab+ac\)`

4.  **Identity property** `\(x+0=x\)` and `\(x\times 1=x\)`

5.   **Inverse property** `\(-x+x=0\)`.

Multiplicative inverse exists, but not for all numbers `\(x^{-1}\times x=1\)`


---
# Intervals and Inequalities 

## Intervals and Inequalities
Ranges of numbers can be expressed with either \[\] or \(\) brackets. 

Notation |      Meaning     |    Explanation 
---------|----------------- |------------------------------------
`\([a,b]\)`  | `\(a \leq x \leq b\)`|Inclusive of end points (closed interval)
`\((a,b)\)`  | `\(a &lt; x &lt; b\)`      |Exclusive of end points (open interval)
`\(\{a,b\}\)`|                  |Typically used for sets -- not inequalities/intervals

---

# Relational Expressions 

- `\(4 &lt; x\)` 

- `\(y&gt;12\)`

- `\(3 &lt;z &lt;7\)`

- `\((3,9)\)`

- `\([-7,2)\)`

---

# Absolute Value

Magnitude of a numerical value indicated by `\(|x|\)`. Solved by typical arithmetic, but must solve for both the negative and positive equations.

For example: 

$$|x + 4| &lt; 5 $$

&gt;- Must be solved as: `\(-x-4&lt;5\)` AND `\(x+4&lt;5\)`

Therefore:

&gt;- `\(-9&lt;x&lt;1\)`  *Notice how the inequality was flipped due to the negative equation* 

&gt;- Try this one out: `\(|\frac{x+2}{x}|&lt;10\)`

&gt;- Answer: `\(-\frac{2}{11} &gt; x &gt; \frac{2}{9}\)`

---

# Factoring

We may need to break down different functions.


`\(x^2+3x-4= (x-1)(x-4)\)`


`\(2x^2+7x+3= (2x+1)(x+3)\)`

---
# Summation 

Using sums can help us when we're summing a large number of items or when summing more complex functions. 

Summation Rules: 

---

# Some Additional Definitions with Summation

- The following section is a bit abstract, but contains some algebraic concepts we set aside for those that might like to learn about formal theory later on.

- It will also be helpful to move on to our next section on *limits*. 

---

# Sequences and Series

--

## Sequences 
A sequence is an ordered list of numbers. They can be infinite or finite, but all are *countable*. Written `\({x_i}^N_{i=1}\)`

--

## Series 

A series is the sum of a sequence, written `\(\Sigma^N_{i=1}x_i\)`. 

---

# Sequences 

- We refer to the elements of a sequence by their position. For example, the third element would be `\(x_3\)`.

- A sequence is generated and represented by some equation wherein each element is a function of the element preceding it. 

- Take the following sequence: `\(\{1, 2, 5, 26, 677...\}\)`. This sequence is defined by the following generating equation:

`$${x_i^2+1}_{i=1}^\infty$$`

- Some sequences are *infinite*, as the sequence above. Others are *finite* and will end at the `\(n\)`th term. 

---

# Series 

- A series will essentially take a sequence and add together each of the numbers, such that our example sequence from the previous slide becomes: `\(\{1+  2+ 5 + 26 + 677...\}\)`. 

- Infinite series will sum to `\(\infty\)` given that they are infinite! Shocking! However, we might also specify to know the sum at a given `\(n\)` term. In which case I would probably just tell you to look up a calculator to do it for you.  

- Finite sums can more easily be summed, again likely with a calculator if `\(N\)` is sufficiently large. 




    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
