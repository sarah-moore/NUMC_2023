<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Matrix Algebra +</title>
    <meta charset="utf-8" />
    <meta name="author" content="Sarah Moore &amp; J. Seawright" />
    <script src="libs/header-attrs-2.21/header-attrs.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Matrix Algebra +
]
.subtitle[
## Day 5 AM
]
.author[
### Sarah Moore &amp; J. Seawright
]
.institute[
### Northwestern University
]
.date[
### Math Camp 2023
]

---



# Introduction to Matrices

A matrix is way of aggregating data by `\(n\)` rows and `\(d\)` columns. We can liken matrices to datasets in that rows data is organized into observations (rows) by columns (variables). 

---
# Introduction to Matrices

Matrices are described based on their `\(n \times d\)` dimensions, that is the number of rows `\(\times\)` columns in the matrix.

Matrices may be characterized by their specific shape. For example, a matrix with an equal number of rows and columns is a square matrix. Otherwise, a matrix is rectangular. 

\begin{columns}

\column{0.5\textwidth}
Square Matrix: 

\[
\begin{bmatrix}
a &amp; b &amp; c \\ 
1 &amp; 0 &amp; 0 \\ 
4 &amp; 8 &amp; 5 \\
\end{bmatrix}
\]

\column{0.5\textwidth}
Rectangular Matrix: 

\[
\begin{bmatrix}
a &amp; b &amp; c &amp; d \\ 
1 &amp; 0 &amp; 0 &amp; 1 \\ 
\end{bmatrix}
\]

\end{columns}

---
# Indexing Data in Matrices 

Like variables matrices are given names. Matrix names are typically capital letters like **$A, B, X, I, \Phi$**. Matrix elements are referenced by the matrix name and the element's row and column number. Generally, this is shown by `\(a_{i,j}\)`. 

Suppose we have the following matrix. What are the dimensions of matrix `\([B]\)` below, and what value is `\(b_{23}\)`?

\[
\begin{bmatrix}
3&amp;2&amp;8&amp;11&amp;14&amp;19 \\
9&amp; 81 &amp; 21&amp; 31&amp; 41&amp; 1 \\
13&amp; 7 &amp; 6 &amp; 4 &amp; 5 &amp; 20
\end{bmatrix}
\]

\pause Dimensions are 3 x 6; `\(b_{23}\)` is 21. 

---
# Elements of Matrices

The elements along the diagonal often are important in matrices. We typically focus upon the diagonal that starts in the upper left and goes down to the lower right. 

\[
[A]=\begin{bmatrix}
1 &amp; 3 &amp; 5 \\
0 &amp; 2 &amp; 4 \\
0 &amp; 0 &amp; 6
\end{bmatrix} 
[B]=
\begin{bmatrix}
1 &amp; 0 &amp; 0 \\
0 &amp; 2 &amp; 0 \\
0 &amp; 0 &amp; 6
\end{bmatrix}
[C]=
\begin{bmatrix}
1 &amp; 0 &amp; 0 \\
3&amp; 2 &amp; 0 \\
5&amp; 4 &amp; 6
\end{bmatrix}
[D]=
\begin{bmatrix}
1 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 \\
0&amp; 0 &amp; 1
\end{bmatrix}
\]


---

# Types of Matrices

We won't get into the details of all sorts of different matrices but it might be helpful to know that there are "special" matrices:

\small 

- Vector Matrices: only one row (row vector) or column (column vector)

- Submatrix: subset of a matrix

- Triangular Matrix: part of matrix is zeros -- all bottom triangle zeros is upper triangular, all upper triangle zeros is lower triangular.

- Diagonal Matrix: only the diagonal is non-zero

- Zero Matrix: everything is zeros

- Identity Matrix ($I$): all zeros except on diagonal AND diagonal is only ones, this is the matrix version of multiplying by 1

- Transpose ($[A]^T$): This is where you flip all the rows/columns. Meaning, if something was row 3, col 2, it will now be row 2, col 3. Done by `reflecting' over the main diagonal (so the diagonal stays the same)

---

# Identifying Matrices
Define the kinds of matrices below: 

\[
[A]=\begin{bmatrix}
1 &amp; 3 &amp; 5 \\
0 &amp; 2 &amp; 4 \\
0 &amp; 0 &amp; 6
\end{bmatrix} 
[B]=
\begin{bmatrix}
1 &amp; 0 &amp; 0 \\
0 &amp; 2 &amp; 0 \\
0 &amp; 0 &amp; 6
\end{bmatrix}
[C]=
\begin{bmatrix}
1 &amp; 0 &amp; 0 \\
3&amp; 2 &amp; 0 \\
5&amp; 4 &amp; 6
\end{bmatrix}
[D]=
\begin{bmatrix}
1 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 \\
0&amp; 0 &amp; 1
\end{bmatrix}
\]

\pause

\textit{A: Upper triangular, B: Zero matrix, C: Lower triangular, D: Identity matrix; Fun fact! A and C are the transpose of each other}

---

# Adding matrices

Adding and subtracting matrices requires that you have matrices that have the same dimensions as each other. You then add the elements together (or subtract, as applicable). The resulting matrix will have the same dimension as the originals. 

\[
 \begin{bmatrix}
1 &amp; 13 &amp; 15 \\
2 &amp; 4 &amp; 6 
\end{bmatrix}
+
\begin{bmatrix}
2 &amp; 4 &amp; 6 \\
1 &amp; 3 &amp; 5 
\end{bmatrix}
=
\begin{bmatrix}
3 &amp; 17 &amp; 23 \\
3 &amp; 7 &amp; 13 
\end{bmatrix}
\]

\[
 \begin{bmatrix}
1 &amp; 13 &amp; 15 \\
2 &amp; 4 &amp; 6 
\end{bmatrix}
-
\begin{bmatrix}
2 &amp; 4 &amp; 6 \\
1 &amp; 3 &amp; 5 
\end{bmatrix}
=
\begin{bmatrix}
-1 &amp; 9 &amp; 9 \\
1 &amp; 1 &amp; 1 
\end{bmatrix}
\]

---

# Multiplying Matrices

&gt;- Just like in every other matrix operation, before you multiply matrices you must define their dimensions. To determine if you *can* multiply matrices, you need the number of **COLUMNS** in the matrix 1 to be the same as the number of **ROWS** in matrix 2. 

&gt;- You can't swap matrix positions like in regular multiplying. A$\times$B is not the same as B$\times$A. 

&gt;- Let's think about what you *should* end up with. You will end up with a matrix equal to the number of ROWS in the FIRST matrix and the number of COLUMNS in the SECOND matrix. For example, `\(A_{2\times3}\times B_{3\times3}\)` will return a matrix `\(C_{2\times3}\)`

&gt;- Now the math gets a bit weird. You go ACROSS the first row of the matrix and multiply it DOWN the first column of the second matrix. Repeat this across each row, column pair.  

---

# Matrix Multiplication

If you have a matrix setup like this: `\(A_{rxs} \times B_{sxt}\)` then you will get a matrix that is `\(C_{r \times t}\)`.
---

# Matrix Multiplication Example 

\[
[A]=\begin{bmatrix}
7 &amp; 8  
\end{bmatrix} 
[B]=
\begin{bmatrix}
2 &amp; 4 &amp; 6 \\
1 &amp; 3 &amp; 5 \\
\end{bmatrix}
\]
 

Let's multiply! You take the row of the first matrix, multiply it by the COLUMN (hence the need to match) of the second matrix, ADD the sum of these products, and that goes into the first cell of the `final' matrix. Then you do the same thing for the next column. 
\pause
So, here, it would be: 
\[
[C]=\begin{bmatrix}
7*2+8*1  &amp; 7*4 + 8*3 &amp; 7*6+8*5
\end{bmatrix}
\] 
Note this is a row vector: `\([C]=\begin{bmatrix}22 &amp; 52 &amp; 82\end{bmatrix}\)`
---
# Multiplying Matrices
If you have multiple rows in your initial matrix, you just do the same process over again, following the same procedure for each row. Your final matrix will have dimensions determined in the same way. For example, if you have a 2 x 3 and a 3 x 3, you'll have a 2 x 3 as your resulting matrix. \pause

\[
[A]=\begin{bmatrix}
7 &amp; 8  \\
1 &amp; 2
\end{bmatrix} 
[B]=
\begin{bmatrix}
2 &amp; 4 &amp; 6 \\
1 &amp; 3 &amp; 5 \\
\end{bmatrix}
\]

\pause
\[
[C]=\begin{bmatrix}
7*2+8*1  &amp; 7*4 + 8*3 &amp; 7*6+8*5 \\
1*2+2*1 &amp; 1*4 + 2*3 &amp; 1*6+2*5
\end{bmatrix}
=\begin{bmatrix}
22 &amp; 52 &amp; 82 \\
4 &amp; 10 &amp; 16
\end{bmatrix}
\] 
---
# Multiplying Matrices: Practice
\[
[A]=
\begin{bmatrix}
1 &amp; 3 &amp; 4 \\
2 &amp; 2 &amp; 8 \\
\end{bmatrix}
[B]=
\begin{bmatrix}
1 &amp; 3 &amp; 5 \\
0 &amp; 2 &amp; 4 \\
0 &amp; 0 &amp; 6
\end{bmatrix} 
[C]=
\begin{bmatrix}
1 &amp; 0 &amp; 0 \\
3&amp; 2 &amp; 0 \\
5&amp; 4 &amp; 6 \\
1 &amp; 1 &amp; 1
\end{bmatrix}
[D]=
\begin{bmatrix}
1 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 \\
0&amp; 0 &amp; 1
\end{bmatrix}
\]

Try the following: 
\begin{itemize}
\item \textbf{A x B}
\item \textbf{B x A}
\item \textbf{A x C}
\item \textbf{B x D}
\end{itemize}
---
# Answers 
\begin{itemize}
\item \textbf{A x B} `\(\begin{bmatrix} 1 &amp; 9 &amp; 41 \\ 2 &amp; 10&amp; 46\end{bmatrix}\)`
\item \textbf{B x A} Not possible: 3 x 3 and 2 x 3 (middle numbers must match)
\item \textbf{A x C} Not possible: 2 x 3 and 4 x 3 (middle numbers must match)
\item \textbf{B x D} B (D is the identity matrix so you always get back whatever you multiplied it by)
\end{itemize}
---
# Matrices: A Rundown 

- Dimensions matter. Different operations place different restrictions on dimensionality. 

- Multiplying matrices does not happen how you would think. Take a minute to think through what matrix multiplication requires. 

- Different types of matrices (especially the transpose and the identity matrices) will become more relevant later on. Remember these! 

- Dividing matrices is even more weird. That's what calculators are for.... 

---
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
